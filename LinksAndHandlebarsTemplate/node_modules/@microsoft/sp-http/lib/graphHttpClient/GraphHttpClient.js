import * as tslib_1 from "tslib";
import { sealed } from '@microsoft/decorators';
import * as lodash from '@microsoft/sp-lodash-subset';
import { _LogSource, _logSourceServiceKey, _QosMonitor } from '@microsoft/sp-diagnostics';
import { ServiceKey, Validate } from '@microsoft/sp-core-library';
import OAuthTokenProvider from '../oauthTokenProvider/OAuthTokenProvider';
import { fetchProviderServiceKey } from '../httpClient/FetchProvider';
import GraphHttpClientResponse from './GraphHttpClientResponse';
import HttpClientHelper from '../httpClient/HttpClientHelper';
import SPHttpClientHelper from '../spHttpClient/SPHttpClientHelper';
import { predefinedConfigurations } from './GraphHttpClientConfiguration';
import GraphHttpClientContext from './GraphHttpClientContext';
var GraphHttpClient = (function () {
    function GraphHttpClient(serviceScope) {
        var _this = this;
        this._serviceScope = serviceScope;
        this._serviceScope.whenFinished(function () {
            _this._tokenProvider = serviceScope.consume(OAuthTokenProvider.serviceKey);
            _this._parentSource = serviceScope.consume(_logSourceServiceKey);
            _this._graphContext = serviceScope.consume(GraphHttpClientContext.serviceKey);
            _this._fetchProvider = serviceScope.consume(fetchProviderServiceKey);
        });
    }
    GraphHttpClient_1 = GraphHttpClient;
    GraphHttpClient.prototype.fetch = function (url, configuration, options) {
        var _this = this;
        this._validateGraphRelativeUrl(url);
        return this._getOAuthToken().then(function () {
            if (!options) {
                options = {};
            }
            var modifiedOptions = lodash.clone(options);
            var defaultHeaders = new Headers();
            defaultHeaders.append('Accept', 'application/json');
            defaultHeaders.append('Authorization', 'Bearer ' + _this._token);
            defaultHeaders.append('Content-Type', 'application/json; charset=utf-8');
            var userHeaders = SPHttpClientHelper.cloneHeaders(options);
            modifiedOptions.headers = _this._mergeUserHeaders(defaultHeaders, userHeaders);
            return _this._fetchWithInstrumentation(configuration, new Request(_this._graphContext.getGraphEndpointUrl() + '/' + url, modifiedOptions)).then(function (response) {
                return new GraphHttpClientResponse(response);
            });
        });
    };
    GraphHttpClient.prototype.get = function (url, configuration, options) {
        return this.fetch(url, configuration, HttpClientHelper.overrideHttpMethod(options, 'GET'));
    };
    GraphHttpClient.prototype.post = function (url, configuration, options) {
        return this.fetch(url, configuration, HttpClientHelper.overrideHttpMethod(options, 'POST'));
    };
    GraphHttpClient.prototype._fetchWithInstrumentation = function (configuration, request) {
        var _this = this;
        var qosMonitor = new _QosMonitor('GraphHttpClient.Fetch');
        return HttpClientHelper.fetchCore(configuration, request, this._serviceScope, this._fetchProvider, GraphHttpClient_1._className).then(function (response) {
            _this._writeQosMonitorUpdate(response, qosMonitor, 'Fetch');
            return response;
        }).catch(function (error) {
            qosMonitor.writeUnexpectedFailure('Fetch', error, { source: _this._logSourceId });
            return Promise.reject(error);
        });
    };
    GraphHttpClient.prototype._getOAuthToken = function () {
        var _this = this;
        var qosMonitor = new _QosMonitor('GraphHttpClient.FetchGraphToken');
        return this._tokenProvider.getOAuthToken(this._graphContext.getGraphEndpointUrl(), this._graphContext.getWebServerRelativeUrl()).then(function (response) {
            _this._writeQosMonitorUpdate(response, qosMonitor, 'FetchGraphToken');
            _this._token = response.token;
        })
            .catch(function (error) {
            qosMonitor.writeUnexpectedFailure('FetchGraphToken', error, { source: _this._logSourceId });
            return Promise.reject(error);
        });
    };
    Object.defineProperty(GraphHttpClient.prototype, "_logSourceId", {
        get: function () {
            if (this._parentSource.isEmpty()) {
                return GraphHttpClient_1._logSource.id;
            }
            return this._parentSource.id;
        },
        enumerable: true,
        configurable: true
    });
    GraphHttpClient.prototype._mergeUserHeaders = function (defaultHeaders, userHeaders) {
        userHeaders.forEach(function (value, name) {
            defaultHeaders.set(name, value); 
        });
        return defaultHeaders;
    };
    GraphHttpClient.prototype._writeQosMonitorUpdate = function (response, qosMonitor, operation) {
        if (response.status >= 200 && response.status <= 299) {
            qosMonitor.writeSuccess({ source: this._logSourceId });
        }
        else if (response.status >= 300 && response.status <= 499) {
            qosMonitor.writeExpectedFailure(operation, undefined, { source: this._logSourceId, responseStatus: response.status });
        }
        else {
            qosMonitor.writeUnexpectedFailure(operation, undefined, { source: this._logSourceId, responseStatus: response.status });
        }
    };
    GraphHttpClient.prototype._validateGraphRelativeUrl = function (url) {
        Validate.isNotNullOrUndefined(url, 'url');
        if (url.charAt(0) === '/') {
            throw new Error('GraphHttpClient requests cannot begin with a / character');
        }
        if (url.indexOf('http://', 0) === 0) {
            throw new Error('GraphHttpClient requests cannot specify a different graph server with the url.');
        }
        if (url.indexOf('https://', 0) === 0) {
            throw new Error('GraphHttpClient requests cannot specify a different graph server with the url.');
        }
    };
    GraphHttpClient.configurations = predefinedConfigurations;
    GraphHttpClient.serviceKey = ServiceKey.create('sp-http:GraphHttpClient', GraphHttpClient_1);
    GraphHttpClient._className = 'GraphHttpClient';
    GraphHttpClient._logSource = _LogSource.create('graphHttpClient');
    GraphHttpClient = GraphHttpClient_1 = tslib_1.__decorate([
        sealed
    ], GraphHttpClient);
    return GraphHttpClient;
    var GraphHttpClient_1;
}());
export default GraphHttpClient;
