"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
const path = require("path");
const fsx = require("fs-extra");
const GulpTask_1 = require("./GulpTask");
const Jest = require("jest-cli");
const globby = require("globby");
const DEFAULT_JEST_CONFIG_FILE_NAME = 'jest.config.json';
/**
 * We need to replace the resolver function which jest is using until the PR which
 * fixes jest-resolves handling of symlinks is merged:
 * https://github.com/facebook/jest/pull/5085
 */
// tslint:disable-next-line:no-any
const nodeModulesPaths = require('jest-resolve/build/node_modules_paths');
nodeModulesPaths.default = (basedir, options) => {
    const nodeModulesFolders = 'node_modules';
    const absoluteBaseDir = path.resolve(basedir);
    const realAbsoluteBaseDir = fsx.realpathSync(absoluteBaseDir);
    const possiblePaths = [realAbsoluteBaseDir];
    let moduleFolders = [nodeModulesFolders];
    if (options && options.moduleDirectory) {
        moduleFolders = [].concat(options.moduleDirectory);
    }
    const windowsBaseRegex = /^([A-Za-z]:)/;
    const fileshareBaseRegex = /^\\\\/;
    let prefix = '/';
    if (windowsBaseRegex.test(absoluteBaseDir)) {
        prefix = '';
    }
    else if (fileshareBaseRegex.test(absoluteBaseDir)) {
        prefix = '\\\\';
    }
    let parsedPath = path.parse(realAbsoluteBaseDir);
    while (parsedPath.dir !== possiblePaths[possiblePaths.length - 1]) {
        const realParsedDir = fsx.realpathSync(parsedPath.dir);
        possiblePaths.push(realParsedDir);
        parsedPath = path.parse(realParsedDir);
    }
    const dirs = possiblePaths.reduce((possibleDirs, aPath) => {
        return possibleDirs.concat(moduleFolders.map((moduleDir) => {
            return path.join(prefix, aPath, moduleDir);
        }));
    }, []);
    if (options.paths) {
        return options.paths.concat(dirs);
    }
    return dirs;
};
/**
 * Indicates if jest is enabled
 * @internal
 * @param rootFolder - package root folder
 */
function _isJestEnabled(rootFolder) {
    const taskConfigFile = path.join(rootFolder, 'config', 'jest.json');
    if (!fsx.existsSync(taskConfigFile)) {
        return false;
    }
    const taskConfig = require(taskConfigFile);
    // tslint:disable-next-line:no-string-literal
    return !!taskConfig['isEnabled'];
}
exports._isJestEnabled = _isJestEnabled;
/**
 * This task takes in a map of dest: [sources], and copies items from one place to another.
 * @alpha
 */
class JestTask extends GulpTask_1.GulpTask {
    constructor() {
        super('jest', {
            cache: true,
            collectCoverageFrom: ['lib/**/*.js?(x)', '!lib/**/test/**'],
            coverage: true,
            coverageReporters: ['json', 'html'],
            testPathIgnorePatterns: ['<rootDir>/(src|lib-amd|lib-es6|coverage|build|docs|node_modules)/']
        });
    }
    isEnabled(buildConfig) {
        return super.isEnabled(buildConfig) && !!this.taskConfig.isEnabled;
    }
    /**
     * Loads the z-schema object for this task
     */
    loadSchema() {
        return require('./jest.schema.json');
    }
    executeTask(gulp, completeCallback) {
        const configFileFullPath = path.join(this.buildConfig.rootPath, 'config', 'jest', DEFAULT_JEST_CONFIG_FILE_NAME);
        this._copySnapshots(this.buildConfig.srcFolder, this.buildConfig.libFolder);
        // tslint:disable-next-line:no-any
        const jestConfig = {
            ci: this.buildConfig.production,
            cache: !!this.taskConfig.cache,
            config: fsx.existsSync(configFileFullPath) ? configFileFullPath : undefined,
            collectCoverageFrom: this.taskConfig.collectCoverageFrom,
            coverage: this.taskConfig.coverage,
            coverageReporters: this.taskConfig.coverageReporters,
            coverageDirectory: path.join(this.buildConfig.tempFolder, 'coverage'),
            maxWorkers: !!this.taskConfig.maxWorkers ?
                this.taskConfig.maxWorkers : 1,
            moduleDirectories: !!this.taskConfig.moduleDirectories ?
                this.taskConfig.moduleDirectories :
                ['node_modules', this.buildConfig.libFolder],
            reporters: [path.join(__dirname, 'JestReporter.js')],
            rootDir: this.buildConfig.rootPath,
            testMatch: !!this.taskConfig.testMatch ?
                this.taskConfig.testMatch : ['**/*.test.js?(x)'],
            testPathIgnorePatterns: this.taskConfig.testPathIgnorePatterns,
            updateSnapshot: !this.buildConfig.production
        };
        if (this.taskConfig.cacheDirectory) {
            // tslint:disable-next-line:no-string-literal
            jestConfig['cacheDirectory'] = this.taskConfig.cacheDirectory;
        }
        // suppress 'Running coverage on untested files...' warning
        const oldTTY = process.stdout.isTTY;
        process.stdout.isTTY = undefined;
        Jest.runCLI(jestConfig, [this.buildConfig.rootPath]).then((result) => {
            process.stdout.isTTY = oldTTY;
            if (result.results.numFailedTests || result.results.numFailedTestSuites) {
                completeCallback(new Error('Jest tests failed'));
            }
            else {
                if (!this.buildConfig.production) {
                    this._copySnapshots(this.buildConfig.libFolder, this.buildConfig.srcFolder);
                }
                completeCallback();
            }
        }, (err) => {
            process.stdout.isTTY = oldTTY;
            completeCallback(err);
        });
    }
    _copySnapshots(srcRoot, destRoot) {
        const pattern = path.join(srcRoot, '**/__snapshots__/*.snap');
        globby.sync(pattern).forEach(snapFile => {
            const destination = snapFile.replace(srcRoot, destRoot);
            if (this._copyIfMatchExtension(snapFile, destination, '.test.tsx.snap')) {
                this.logVerbose(`Snapshot file ${snapFile} is copied to match extension ".test.tsx.snap".`);
            }
            else if (this._copyIfMatchExtension(snapFile, destination, '.test.ts.snap')) {
                this.logVerbose(`Snapshot file ${snapFile} is copied to match extension ".test.ts.snap".`);
            }
            else if (this._copyIfMatchExtension(snapFile, destination, '.test.jsx.snap')) {
                this.logVerbose(`Snapshot file ${snapFile} is copied to match extension ".test.jsx.snap".`);
            }
            else if (this._copyIfMatchExtension(snapFile, destination, '.test.js.snap')) {
                this.logVerbose(`Snapshot file ${snapFile} is copied to match extension ".test.js.snap".`);
            }
            else {
                this.logWarning(`Snapshot file ${snapFile} is not copied because don't find that matching test file.`);
            }
        });
    }
    _copyIfMatchExtension(snapSourceFile, destinationFile, extension) {
        const snapDestFile = destinationFile.replace(/\.test\..+\.snap$/, extension);
        const testFileName = path.basename(snapDestFile, '.snap');
        const testFile = path.resolve(path.dirname(snapDestFile), '..', testFileName); // Up from `__snapshots__`.
        if (fsx.existsSync(testFile)) {
            fsx.copySync(snapSourceFile, snapDestFile);
            return true;
        }
        else {
            return false;
        }
    }
}
exports.JestTask = JestTask;

//# sourceMappingURL=JestTask.js.map
